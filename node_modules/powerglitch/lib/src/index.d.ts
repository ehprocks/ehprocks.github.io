/**
 * Available play modes
 * @remarks
 * - always: Always glitch (default)
 * - hover: Glitch on hover
 * - click: Glitch will start on each click
 * - manual: Glitch controlled with returned callbacks
 */
export declare type PlayModes = 'always' | 'hover' | 'click' | 'manual';
/**
 * Custom options for the glitch animations.
 */
export declare type PowerGlitchOptions = {
    /**
     * Html to glitch. If not provided, will use the elements themselves. If provided, all elements should have an `innerHTML` property.
     */
    html?: string;
    /**
     * Whether to create the 2 containers (one containing the other) necessary to create the glitch animation (defaults to true).
     * @remarks
     * The glitch effect relies on cloning the glitched element, and stacking them on top of the others inside 2 containers (one containing the other).
     * The embedded container is called the layer container, it has grid display and stacks its children, which are the original element and its cloned versions.
     * The top-level container replaces the original element (and the element is moved inside the layer container)
     * This logic is necessary to ensure layout consistency before/after the glitch, and to create the actual glitch effect with CSS.
     * In short, this maximizes compatibility for gitching about anything, but has to rearrange the DOM for that purpose.
     *
     * In some cases, it is better to handle this logic of two containers elsewhere than in PowerGlitch.
     * For that, this flag should be false, which will make PowerGlitch.giltch(..) assume:
     *  - That the first argument to glitch(..) is the layer container itself
     *  - That the first child of the layer container is the element to glitch
     * And will:
     *  - Clone the element to glitch the required amount of times, and add the clones at the same level than the element to glitch in the layer container
     */
    createContainers: boolean;
    /**
     * While you can control the glitch with the startGlitch/stopGlitch methods,
     * You can also set a default behavior for playing the glitch.
     */
    playMode: PlayModes;
    /**
     * Whether to hide the glitch animation when it goes out of the bounding rectangle.
     */
    hideOverflow: boolean;
    /**
     * Timing of the animation.
     */
    timing: {
        /**
         * Duration of the animation loop in milliseconds.
         */
        duration: number;
        /**
         * Number of times the animation should repeat. Set to `Infinity` to repeat forever.
         */
        iterations: number;
        /**
         * Ease animation for all layers. Defauls to a sequential easing (no transition).
         */
        easing?: string;
    };
    /**
     * Specify if the animation should always glitch uniformly (if false) or if it should glitch at a given time.
     * @remarks
     * If start and end are set, the animation will glitch between those two times, and the peak glitch will be at the middle.
     * glitchTimeSpan.end should be greater than glitchTimeSpan.start. Otherwise, the glitch will not happen.
     */
    glitchTimeSpan: false | {
        /**
         * Start time of the glitch in percent, between 0 and 1.
         */
        start: number;
        /**
         * End time of the glitch in percent, between 0 and 1.
         */
        end: number;
    };
    /**
     * Whether the base layer should shake. If not set to false, the base layer will shake in the given amplitude.
     * @remarks
     * The shake animation respects the glitch time span constraint, if set.
     */
    shake: false | {
        /**
         * Number of steps to compute for each layer per second of animation.
         */
        velocity: number;
        /**
         * Max X amplitude for the shake animation.
         */
        amplitudeX: number;
        /**
         * Max Y amplitude for the shake animation.
         */
        amplitudeY: number;
    };
    /**
     * Slice layers are the base animation to give the glitch effect. They clip a part of the element and move it somewhere else.
     * @remarks
     * The slice animation respects the glitch time span constraint, if set.
     */
    slice: {
        /**
         * Number of layers to generate.
         */
        count: number;
        /**
         * Number of steps to compute for each layer per second of animation.
         */
        velocity: number;
        /**
         * Minimum height in percent for a given slice, between 0 and 1.
         */
        minHeight: number;
        /**
         * Maximum height in percent for a given slice, between 0 and 1.
         */
        maxHeight: number;
        /**
         * Whether the hue should rotate for the given slice.
         */
        hueRotate: boolean;
    };
    /**
     * Pulse layer adds a pulsing effect to the glitch.
     */
    pulse: false | {
        /**
         * Max scale
         */
        scale: number;
    };
};
/**
 * Definition for one layer, part of the glitch animation.
 */
export declare type LayerDefinition = {
    /**
     * Each animation step is a hashmap linking CSS property names to their value for this step.
     */
    steps: {
        [cssPropertyName: string]: string;
    }[];
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/KeyframeEffect#parameters
     */
    timing: EffectTiming;
};
/**
* Performs a deep merge of option objects and returns new object. Does not modify
* objects (immutable) and will ignore arrays.
* @param objects - Objects to merge
* @returns New object with merged key/values
*/
export declare const mergeOptions: (...objects: readonly any[]) => any;
/**
 * Utility class to have optional properties on a type recursively
 */
export declare type RecursivePartial<T> = {
    [P in keyof T]?: RecursivePartial<T[P]>;
};
/**
 * Options given to the glitch method
 */
export declare type GlitchPartialOptions = RecursivePartial<PowerGlitchOptions>;
/**
 * Specifies what to glitch. Query selector, html element, list of html elements or NodeList.
 */
export declare type GlitchableElement = string | HTMLElement | NodeListOf<HTMLElement> | Array<HTMLElement>;
/**
 * The result for glitching one or multiple elements.
 */
export declare type GlitchResult = {
    /**
     * Lists of containers for each glitched element.
     */
    containers: HTMLDivElement[];
    /**
     * Callback to force-start the glitch animation regardless of the selected play mode.
     */
    startGlitch: () => void;
    /**
     * Callback to force-stop the glitch animation, regardless of the selected play mode.
     */
    stopGlitch: () => void;
};
export declare const PowerGlitch: {
    glitch: (elOrSelector?: GlitchableElement, userOptions?: GlitchPartialOptions) => GlitchResult;
    generateLayers: (options: PowerGlitchOptions) => LayerDefinition[];
    getDefaultOptions: (playMode?: PlayModes) => PowerGlitchOptions;
};
